/**
 * 设爬到当前楼梯n 的方案为 dp[i] 
 * dp[i] 由dp[i-1] 和dp[i-2]决定。 所以 dp[i] = dp[i-1] + dp[i-2]
 * 
 */
function main(n){
    /**
     * 记忆化搜索是一种"从顶至底"的方法：从原问题(根节点)出发，
     * 递归将较大子问题分解为较小子问题，直至解已知的最小问题(叶节点)。然后通过回溯收集问题的解。
     */

    /**
     * 动态规划是一种  "从底到顶"的方法: 从最小问题的解开始，迭代地构建更大子问题的解，直至得到原问题的解。
     * 1. 数组dp: dp表，dp[i]表示状态i对应子问题的解。
     * 2. 最小子问题对应状态称为初始状态
     * 3. 递推公式称为状态转移方程。
     */
    if(n === 1 || n === 2){
        return n
    }
    const dp = Array(n+1).fill(0)
    dp[1] = 1
    dp[2] = 2
    for(let i = 3;i<=n;i++){
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
}
const n = main(40000)
console.log(n)